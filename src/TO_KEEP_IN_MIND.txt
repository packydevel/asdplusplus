To Keep in Mind:
----------------

5) Un puntatore void* non può essere dereferenziato a meno di casting e non si può avere un passagio di parametri by reference attraverso void&

8) In C++ esiste il Global Scope. Per accedere ad una variabile x in global scope che sia offuscata si usa ::x

9) E' possibile definire e innestare i namespace. Inoltre è possibile definire namespace alias che si riferiscano ad altri namespace
    
12) Il compilatore C++ non esegue alcun controllo sugli indici usati per accedere ad un array

13) In C++ esiste il tipo builtin string

14) All'interno di una classe C++ non è necessario usare il forward declaration tra membri. Il compilatore sarà in grado di individuare attributi
    o metodi definiti in un punto successivo rispetto a quello che attualmente il compilatore sta analizzando.
    
15) Un Costruttore che inizializza degli attributi può usare in alternativa all'operazione di assegnamento, una initialization list

16) Quando si crea una variabile di tipo puntatore e tale variabile non si inizializza con l'indirizzo di memoria di alcuna variabile
    creata in precedenza allora conviene in ogni caso inizializzare la variabile puntatore a zero in modo tale che con un if si riesce
    testare se la variabile puntatore sta puntando a qualcosa o meno visto che puntare a zero significa di fatti puntare a niente.
    Esempio:
    
    int* p = 0;
    
17) In C++ (C) variabili allocate con l'operatore new (malloc) devono essere esplicitamente deallocate con l'operatore delete (free)
    E' importante ricordare che la deallocazione libera spazio nell'Heap ma il riferimento all'indirizzo di memoria restituito
    inizialmente dall'operatore new non viene eliminato. Ciò significa che sarebbe per assurdo eseguire nuovamente una delete
    causando un comportamento non predicibile a priori. Pertanto conviene immediatamente assegnare il puntatore al valore 0 dopo avere
    eseguito la delete. Esempio:
    
    int* p = new int;
    ...
    delete p;
    p = 0;
    
    Nel caso di allocazione di array, la deallocazione deve essere esguita come segue e usando sempre la best practice indicata poc'anzi:
    
    int* p = new int[100];
    ...
    delete [] p;
    p=0;
    
18) In C++ struct e class sono esattamente identiche in tutto tranne che in un unico aspetto: il modificatore di default dei membri di una 
	struct è public mentre il modificatore di default dei membri di una class è private.    	
	

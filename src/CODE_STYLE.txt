Code Style:
-----------

1)
Utilizzate linee vuote per separare elementi logicamente distinti, anche
all’interno della singola funzione o blocco applicativo. Cercate di limitare
gli elementi decorativi nei commenti, che deviano l’attenzione di chi legge.
Cercate di inserire un commento a riga songola all'inizio del gruppo di elementi
logicamente distinti.

2) Usare lo stile K&R

3) Definite uno standard di indentazione che sia rispettato da ogni membro del
team di sviluppo.

4) Organizzazione di un file Header come segue:
Nome del file (commento)
Breve descrizione del contenuto (commento)
[ Include di altri header ]
[ Macro costanti ]
[ Macro funzioni ]
[ Typedef ]
[ Enum ]
[ Classe ]
[ Funzioni inline ]
[ Const extern ]
[ Variabili extern ]
[ Funzioni extern ]
[ Operatori extern ]

5) Nella scrittura di espressioni matematiche utilizzate le parentesi solo quando
   sono necessarie ai fini semantici, o per chiarire la priorità e/o l’associatività
   degli operatori.
   Nella scrittura di espressioni logiche, separate con parentesi tonde i predicati che
   sono costituiti da espressioni non atomiche.
   
6) Specificare il nome dei parametri formali sia nel file header o nel proptotipo che
   nel file di implementazione, ed utilizzare gli stessi identificatori in entrambi i
   contesti.
   
7) Impostate una dimensione massima del numero di colonne nell'editor dell'IDE in modo
   tale che ill processo di beautifying del codice lo formatti entro tale limite di
   colonne e quindi rendere il codice stampabile.
   
8) Impostate il beautifier in modo tale che imposti l’allineamento nelle dichiarazioni
   di variabili e/o costanti correlate logicamente tra loro (la correlazione si capisce
   con la riga bianca separa i gruppi di variabili correlate). Esempio:
   
   Color foreground;
   Color background;
   
   long x;
   long y;
   int  w;
   int  h;
   
   List  edges;
   Node* current;
   
   Questa impostazione dovrebbe essere valida anche per gli attributi delle classi e per i
   parametri formali delle funzioni quando la definizione della funzione stessa necessita
   di più righe.
   
9) Impostate il beautifier in modo tale che se la definizione o l'invocazione di una
   funzione supera il limite massimo di colonne definito nell'editor allora lo stile di
   formattazione sia come nell'esempio seguente:
   
   void functionWithManyParameters(param1,
                                   param2,
                                   param3,
                                   param4);
                                   
10) Dichiarare una sola variabile in ogni statement di dichiarazione.

11) Variabili di tipo puntatore (o di tipo riferimento) vanno dichiarate
    giustapponendo il simbolo * (o il simbolo &) al tipo dell’oggetto puntato (o
    referenziato), ovvero come nell’esempio che segue:
    
    int* x; (int& x;)
    
12) Se utilizzate tipi complessi, ad esempio puntatori a funzione, dichiarate un
    tipo apposito con typedef.

13) Utilizzate sempre la struttura di controllo che meglio esprime le azioni che
    intendete compiere ad un livello più astratto.
    
14) Preferire il break o un flag al return per uscire dai loop. Tenete conto che è
    possibile sostituire un break attraverso il test su una variabile booleana.
    Se necessariamente si vuole evitare l'uso di flsg booleani allora è conveniente
    generare eccezioni e gestirle.
 
15) Se il body di uno statement è vuoto, posizionate il ‘;’ o un blocco vuoto su
    una riga separata, ed annotatelo con un commento.
    
16) Nei cicli for, utilizzate un limite inferiore inclusivo ed un limite superiore
    esclusivo. Esempio:
    
    for( int i = 0; i < 10; i++ ) {}
    
    Vi sono due vantaggi in questo:
    1. possiamo contare il numero di cicli con una semplice sottrazione dei
       due limiti.
    2. possiamo usare la dimensione di un array come limite superiore, senza
       preoccuparci di sottrarre 1.
       
17) Ogni clausola di uno statement switch va terminata con break o con return,
    salvo i casi di fall-through intenzionale che devono sempre essere
    commentati.
    
18) Introdurre sempre una clausola default negli statement switch; se il
    controllo non deve mai raggiungere tale clausola, inserire una asserzione
    falsa come corpo, in modo che ogni violazione delle assunzioni fatte venga
    segnalata a run-time.
    
19) Si Suggerisce l'organizzazione delle sezioni di una classe come segue:
    [ Typedef ]
    [ Enum ]
    [ Classi annidate ]
    [ Const ]
    [ Variabili membro statiche ]
    [ Variabili membro ]
    [ Funzioni membro statiche ]
    [ Costruttori ]
    [ Distruttore ]
    [ Funzioni membro ]
    [ Operatori membro ]
    
20) Si suggerisce il seguente raggruppamento in base alla visibilità
    public/protected/private/friend:

    [ Sezione pubblica ]
    [ Sezione protetta ]
    [ Sezione privata ]
    [ Classi friend ]
    [ Funzioni friend ]
    [ Operatori friend ]
    
21) La definizione delle funzioni inline non va inserita all’interno della
    dichiarazione della classe, ma al di fuori di essa.
    
22) Nei commenti, cercate di spiegare le vostre intenzioni, non come le state
    realizzando. Preferite i commenti introduttivi a quelli esplicativi, che spesso
    si possono evitare scrivendo codice più chiaro.
    In questo modo anche se l'implementazione cambia il commento non cambierà dato
    che spiega le intenzioni del programmatore e non come implementa le proprie
    intenzioni.
    Tali commenti dovrebbero essere indicati prima di iniziare il frammento di codice
    che implementa l'intenzione (ossia sulla riga precedente) a dovrebbero essere
    indenetati alla stessa colonna della prima riga di codice che segue il commento
    per evitare ambiguità relative a quale riga di codice quel commento si riferisce
    (la successiva o la precedente ???)
    
23) Preferire l'uso di const o enum rispetto a #define per dichiarare le costanti.
    Ciò per diverse ragioni:
    1. La direttiva #define è gestita dal preprocessore, non dal compilatore. Il
       preprocessore è molto rudimentale, e non ha alcuna gestione dei tipi,
       dello scope, e così via. Pertanto, volendo ad esempio dichiarare una
       costante locale, si ottiene comunque una dichiarazione di visibilità globale
       ogni occorrenza di quella costante a partire dal punto di definizione verrà
       sostituita dal preprocessore a meno di ricordarsi di usare la direttiva #undef.
       
    2. La mancanza di una dichiarazione di tipo esplicita può causare subdoli problemi
       di portabilità, in quanto il compilatore può assumere il tipo più idoneo
       (normalmente il tipo più piccolo che può contenere il valore)
       
    3. I simboli definiti con #define non sono normalmente disponibili in fase
       di debugging, dove quindi troveremo solo i valori numerici corrispondenti;
       molti debugger possono invece visualizzare i nomi simbolici dei tipi
       enumerati ed in alcuni casi delle costanti dichiarate con const.
       
    4. L’uso di #define è associato ad un errore piuttosto comune, dal quale i
       programmatori esperti si guardano in modo pressoché automatico, ma che può
       comunque causare bug abbastanza difficili da rintracciare:
       
       #define 2PI PI + PI
       
       float Circumference( float radius )
       {
          return( radius * 2PI ) ; // restituisce ( radius * PI ) + PI !!
       }
    
23) Se una costante individua un valore numerico usare const che consente una corretta
    tipizzazione e dunque l'uso errato di tale costante è segnalato a compile-time.
    
24) Per le costanti che non designano valori numerici è possibile utilizzare enum che
    comunque crea un nuovo tipo di dato definito appunto per enumerazione dei suoi
    possibili valori.